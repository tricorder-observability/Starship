# Modules

Modules stores the pre-built modules.
Each module has BCC C file, and wasm C file, and build files for building WASM.

## Writing modules
The main purpose of modules is to provide a way to write eBPF and parser code, and then
compile it to WASM, and then deploy it to the agent.

Startship modules are composed of three parts: eBPF code, WASM code, and module definition.
* eBPF: Ebpf side code can be written by all major frontend languages of writing eBPF programs,  including:
    * [BCC](https://github.com/iovisor/bcc)
    * [BPFtrace](https://github.com/iovisor/bpftrace)
    * Rust ([readbpf](https://github.com/foniod/redbpf)[aya](https://github.com/aya-rs/aya))
* WASM: WASM side code can be written by any language that can compile to WASM, including:
    * C
    * Rust
    * Go
    * AssemblyScript
    * etc.
* module definition: including module name, module description, module version, module deployment information, etc.



## Example
As an example, the `sample_event` module has the following structure:

```shell
➜  sample_event git:(doc/modules) ✗ ls -al 
total 156
drwxr-xr-x 2 root root   4096 Feb 21 14:15 .
drwxr-xr-x 6 root root   4096 Feb 20 12:52 ..
-rw-r--r-- 1 root root    152 Feb 20 12:52 BUILD.bazel
-rw-r--r-- 1 root root    310 Feb 21 14:15 Makefile
-rw-r--r-- 1 root root    697 Feb 21 14:15 README.md
-rw-r--r-- 1 root root    164 Feb 20 12:52 event.h
-rw-r--r-- 1 root root    550 Feb 20 12:52 event_bindgen.h
-rw-r--r-- 1 root root    623 Feb 21 14:15 module.json
-rw-r--r-- 1 root root    709 Feb 20 12:52 sample_event.bcc
-rw-r--r-- 1 root root   1172 Feb 21 14:15 write_events_to_output.c
-rwxr-xr-x 1 root root 118332 Feb 21 14:15 write_events_to_output.wasm
```

### sample_event.bcc 
BCC C file, it will be compiled to BPF bytecode by [BCC](https://github.com/iovisor/bcc), and then loaded into the kernel, if you have any questions about BCC, please refer to BCC [reference_guide](https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md)
```c
#include <linux/ptrace.h>

// linux/sched.h already defines this
#ifdef TASK_COMM_LEN
#undef TASK_COMM_LEN
#endif
#define TASK_COMM_LEN 13

// Copied from event.h
// No mechanism to include header for BCC, so this has to be inlined.
// We need to figure out a way to produce pre-processed C file.
struct event_t {
  float F;
  char C;
  double D;
  int I;
  long long int L;
  short Comm[TASK_COMM_LEN];
};

BPF_PERF_OUTPUT(events);

// Just writes fixed events to perf buffer.
int sample_event(struct bpf_perf_event_data *ctx) {
  struct event_t event = {};

  event.F = 1.0;
  event.C = 'a';
  event.D = 3.0;
  event.I = 10;
  event.L = 123;

  events.perf_submit(ctx, &event, sizeof(event));
  return 0;
}
```
In this example, it define a perf event that periodically submits event to perf buffer. If you have any questions about BPF, please refer to BPF [reference_guide](https://www.kernel.org/doc/html/latest/bpf/index.html)

### event.h
event struct definition
It has to be inlined in BCC C file, because there is no mechanism to include header for BCC. we need to this because we need to produce pre-processed C struct definition for parse perf buffer data in WASM correctly.
```c
// LINT_C_FILE
#pragma once
#define TASK_COMM_LEN 13

struct event_t {
  float F;
  char C;
  double D;
  int I;
  long long int L;
  short Comm[TASK_COMM_LEN];
};
```


### event_bindgen.h
event struct definition for WASM. It was generated by [bindgen](https://github.com/eunomia-bpf/c-struct-bindgen) from event.h by running the following command:
```shell
ecc event.h --header-only && struct-bindgen event.bpf.o -p >event_bindgen.h
```

### write_events_to_output.c
WASM C file, it will be compiled to WASM binary file by [emscripten](https://emscripten.org/), and then loaded into the WASM runtime, if you have any questions about WASM, please refer to WASM [reference_guide](https://webassembly.org/docs/)
```C
#include "../common/cJSON.h"
#include "../common/io.h"

#include "event_bindgen.h"

static_assert(sizeof(struct event_t) == 64, "Size of event2 is not 64");

// A simple function to copy entire input buf to output buffer.
// Return 0 if succeeded.
// Return 1 if failed to malloc output buffer.
int write_events_to_output() {
  struct event_t event;
  event.F = 2 * event.F;
  event.D = 2 * event.D;
  event.I = 2 * event.I;
  event.L = 2 * event.L;

  cJSON *root = cJSON_CreateObject();

  cJSON_AddNumberToObject(root, "F", event.F);
  cJSON_AddNumberToObject(root, "D", event.D);
  cJSON_AddNumberToObject(root, "I", event.I);
  cJSON_AddNumberToObject(root, "L", event.L);
  cJSON_AddStringToObject(root, "Comm", (const char *)event.Comm);

  char *json = NULL;
  json = cJSON_Print(root);
  cJSON_Delete(root);

  int json_size = strlen(json);
  void *buf = malloc_output_buf(json_size);
  if (buf == NULL) {
    return 1;
  }
  copy_to_output(json, json_size);
  // Free allocated memory from JSON_print().
  free(json);
  return 0;
}

// Do nothing
// TODO(yaxiong): Investigate how to remove this and build wasi module without
// main().
int main() { return 0; }
```

### write_events_to_output.wasm 
WASM binary file, compiled by  `write_events_to_output.c` and `event_bindgen.h` by running the following command:
```shell
WASI_CLANG := WASI_SDK_PATH=/opt/wasi-sdk /opt/wasi-sdk/bin/clang
CFLAGS := --sysroot=/opt/wasi-sdk/share/wasi-sysroot -Wall -Wextra -Wl,--export-all

$(WASI_CLANG) write_events_to_output.c ../common/cJSON.c -o write_events_to_output.wasm
```

### Makefile
Makefile to  compile WASM C file to WASM binary file
```makefile
all: write_events_to_output.wasm

WASI_CLANG := WASI_SDK_PATH=/opt/wasi-sdk /opt/wasi-sdk/bin/clang
CFLAGS := --sysroot=/opt/wasi-sdk/share/wasi-sysroot -Wall -Wextra -Wl,--export-all

write_events_to_output.wasm:
        $(WASI_CLANG) $(CFLAGS) write_events_to_output.c ../common/cJSON.c -o $@

clean:
        rm -f *.wasm
```
If `sample-event` module WASM file have some changes, you can run `make` to recompile WASM file.

### module.json
module definition
```json
{
    "name":"sample_event_module",
    "wasm":{
        "code":"",
        "fn_name":"write_events_to_output",
        "output_schema":{
            "name":"",
            "fields":[
                {
                    "name":"data",
                    "type": 5
                }
            ]
        }
    },
    "ebpf":{
        "code":"",
        "perf_buffer_name":"events",
        "probes":[
            {
                "sample_period_nanos": 100000000,
                "target":"",
                "entry":"sample_event",
                "return":"",
                "type": 5
            }
        ]
    }
}
```
please note these fields:
- `wasm.fn_name`: the WASM function name that will be called when perf buffer event is received, in this example, it is `write_events_to_output`, it has defined in `write_events_to_output.c`
- `wasm.output_schema`: the output schema of WASM function, it defines the output data format of WASM function. In this example, it is a single field of type `bytes`, which means the WASM function will return a byte array.
- `ebpf.probes`: the eBPF probe definition, it defines the eBPF probe that will be attached to the kernel. It have these fields:
    - `sample_period_nanos`: the sample period of the probe, this is needed for perf buffer probe, it defines how often the perf buffer event will be triggered.
    - `entry`: the eBPF function name that will be called when the probe is triggered.
    - `target`: the target function name that will be probed, it can be a kernel function name, a syscall function name, a user space program function name, or a tracepoint function name.
    - `return`: the return function name was used for kretprobe and uretprobe probe, when the return function returns, the entry function will be called. 
    - `type`: the probe type, Starship supports 5 types of probe: 
        - `ProbeSpec_KPROBE`: kprobe kernel function
        - `ProbeSpec_SYSCALL_PROBE`: kprobe syscall function
        - `ProbeSpec_UPROBE`: uprobes user space program function
        - `ProbeSpec_TRACEPOINT`: tracepoint kernel function
        - `ProbeSpec_SAMPLE_PROBE`: sample probe, it will be triggered periodically in Ebpf.
        ```Go
        ProbeSpec_KPROBE        ProbeSpec_Type = 0
        ProbeSpec_SYSCALL_PROBE ProbeSpec_Type = 1
        ProbeSpec_UPROBE        ProbeSpec_Type = 2
        ProbeSpec_TRACEPOINT    ProbeSpec_Type = 3
        ProbeSpec_XDP           ProbeSpec_Type = 4
        ProbeSpec_SAMPLE_PROBE  ProbeSpec_Type = 5
        ProbeSpec_USDT          ProbeSpec_Type = 6
        ```
- `ebpf.perf_buffer_name`: the perf buffer name, it is used to define the perf buffer name in eBPF code, and it will be used to define the perf buffer name in WASM code.

In this example, it is a perf buffer probe that will be triggered every 100ms, and the perf buffer name is `events`. The `sample_event` function will be called when the perf buffer event is received. The `write_events_to_output` function will be called when the `event` perf buffer event is received in WASM instance.


## Deploy the module
using `starship` CLI to deploy `sample-event` module
- create module

```shell
$ starship-cli module create -b ./sample_event.bcc -w ./write_events_to_output.wasm -m ./module.json --api-address your-api-server-address:8080

{"data":null,"code":"200","message":"create success, module id:c7bd055a_f34a_428c_bb22_e20e7df7edd6"}
```

- deploy module

```shell
$ starship-cli module deploy --api-address your-api-server-address:8080 -i c7bd055a_f34a_428c_bb22_e20e7df7edd6

{"data":null,"code":"200","message":"prepare deploy, please wait a moment."}
```
